<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Word Sketch Lucene Demo</title>
    <style>
        * { box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: #f5f5f5;
        }
        h1 { color: #333; margin-bottom: 5px; }
        .subtitle { color: #666; margin-bottom: 30px; }
        .search-box {
            display: flex;
            gap: 10px;
            margin-bottom: 30px;
        }
        input[type="text"] {
            flex: 1;
            padding: 12px 16px;
            font-size: 16px;
            border: 2px solid #ddd;
            border-radius: 8px;
        }
        input[type="text"]:focus {
            outline: none;
            border-color: #4a90d9;
        }
        select {
            padding: 12px 16px;
            font-size: 16px;
            border: 2px solid #ddd;
            border-radius: 8px;
            background: white;
        }
        button {
            padding: 12px 24px;
            font-size: 16px;
            background: #4a90d9;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
        }
        button:hover { background: #357abd; }
        button:disabled { background: #ccc; }
        .pos-filters {
            display: flex;
            gap: 8px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        .pos-filters label {
            display: flex;
            align-items: center;
            gap: 4px;
            padding: 8px 12px;
            background: white;
            border-radius: 6px;
            cursor: pointer;
            border: 1px solid #ddd;
        }
        .pos-filters input:checked + span {
            font-weight: bold;
            color: #4a90d9;
        }
        .results { display: grid; gap: 20px; }
        .sketch-section {
            background: white;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        .sketch-section h3 {
            margin: 0 0 15px 0;
            color: #333;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .sketch-section .pos-tag {
            background: #e8f4fd;
            color: #4a90d9;
            padding: 4px 10px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: bold;
        }
        .collocation {
            display: flex;
            justify-content: space-between;
            padding: 8px 12px;
            border-bottom: 1px solid #eee;
        }
        .collocation:last-child { border-bottom: none; }
        .collocation .word { font-weight: 500; }
        .collocation .score {
            color: #666;
            font-size: 14px;
        }
        .collocation .freq { color: #999; font-size: 12px; }
        .examples {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #eee;
        }
        .examples h4 {
            margin: 0 0 10px 0;
            color: #666;
            font-size: 14px;
        }
        .example {
            padding: 8px 12px;
            background: #f9f9f9;
            border-radius: 6px;
            margin-bottom: 8px;
            font-size: 14px;
        }
        .example .highlight {
            background: #fff3cd;
            padding: 0 2px;
            border-radius: 2px;
        }
        .loading {
            text-align: center;
            padding: 40px;
            color: #666;
        }
        .error {
            background: #fee;
            color: #c00;
            padding: 20px;
            border-radius: 8px;
        }
        .api-config {
            background: #fff8e0;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
        }
        .api-config label {
            display: block;
            margin-bottom: 5px;
            font-size: 14px;
        }
        .api-config input {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        .tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            border-bottom: 2px solid #ddd;
        }
        .tab {
            padding: 12px 24px;
            background: none;
            border: none;
            border-bottom: 3px solid transparent;
            cursor: pointer;
            font-size: 16px;
            color: #666;
        }
        .tab.active {
            color: #4a90d9;
            border-bottom-color: #4a90d9;
            font-weight: 500;
        }
        .tab-content {
            display: none;
        }
        .tab-content.active {
            display: block;
        }
        .snowball-controls {
            display: grid;
            grid-template-columns: 2fr 1fr 1fr 1fr;
            gap: 10px;
            margin-bottom: 20px;
        }
        .snowball-controls input,
        .snowball-controls select {
            padding: 12px;
            font-size: 14px;
            border: 2px solid #ddd;
            border-radius: 8px;
        }
        #snowballGraph {
            width: 100%;
            height: 600px;
            background: white;
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        .snowball-stats {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            margin-top: 20px;
        }
        .stat-card {
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        .stat-card h4 {
            margin: 0 0 5px 0;
            color: #666;
            font-size: 12px;
            text-transform: uppercase;
        }
        .stat-card .value {
            font-size: 28px;
            font-weight: bold;
            color: #4a90d9;
        }
        .radial-button {
            margin-left: auto;
            padding: 6px 10px;
            font-size: 12px;
            background: #f0f5ff;
            color: #357abd;
            border: 1px solid #cfe0ff;
            border-radius: 6px;
            cursor: pointer;
        }
        .radial-button:hover { background: #e4efff; }
        .radial-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }
        .radial-modal.active { display: flex; }
        .radial-content {
            background: white;
            border-radius: 12px;
            width: 880px;
            max-width: 95vw;
            padding: 20px;
            box-shadow: 0 8px 30px rgba(0,0,0,0.2);
        }
        .radial-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        .radial-title {
            font-size: 18px;
            font-weight: 600;
            color: #333;
        }
        .radial-subtitle {
            font-size: 13px;
            color: #666;
            margin-bottom: 8px;
        }
        .radial-close {
            background: none;
            border: none;
            font-size: 18px;
            cursor: pointer;
            color: #666;
        }
        .radial-legend {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
            font-size: 12px;
            color: #666;
            margin-top: 8px;
        }
        .radial-legend span {
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }
        .radial-legend .dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            display: inline-block;
        }
        .adj-row { cursor: pointer; }
        .adj-row:hover { background: #f7fbff; }
    </style>
</head>
<body>
    <h1>Word Sketch Lucene</h1>
    <p class="subtitle">Corpus-based collocation analysis powered by Apache Lucene</p>

    <div class="api-config">
        <label>API URL:</label>
        <input type="text" id="apiUrl" value="http://localhost:8080" placeholder="http://localhost:8080">
    </div>

    <div class="tabs">
        <button class="tab active" onclick="switchTab('sketch')">Word Sketch</button>
        <button class="tab" onclick="switchTab('semantic')">Semantic Field Explorer</button>
    </div>

    <div id="sketchTab" class="tab-content active">
        <div class="search-box">
            <input type="text" id="wordInput" placeholder="Enter a word (e.g., 'problem', 'house', 'run')" autofocus>
            <select id="posFilter">
                <option value="">All POS</option>
                <option value="noun">Nouns</option>
                <option value="verb">Verbs</option>
                <option value="adj">Adjectives</option>
                <option value="adv">Adverbs</option>
            </select>
            <button id="searchBtn" onclick="search()">Search</button>
        </div>

        <div class="pos-filters">
            <label><input type="checkbox" checked onchange="filterPos('noun')"> <span>Nouns (n)</span></label>
            <label><input type="checkbox" checked onchange="filterPos('verb')"> <span>Verbs (v)</span></label>
            <label><input type="checkbox" checked onchange="filterPos('adj')"> <span>Adjectives (adj)</span></label>
            <label><input type="checkbox" checked onchange="filterPos('adv')"> <span>Adverbs (adv)</span></label>
        </div>

        <div id="results" class="results"></div>
    </div>

    <div id="semanticTab" class="tab-content">
        <div class="snowball-controls">
            <input type="text" id="semanticNouns" placeholder="Nouns to compare (comma-separated, e.g., theory,model,hypothesis)">
            <input type="number" id="semanticMinLogDice" value="3.0" step="0.5" min="0" placeholder="Min LogDice">
            <input type="number" id="semanticMaxPerNoun" value="50" min="10" max="100" placeholder="Max per noun" title="Maximum adjectives per noun">
        </div>
        <button onclick="runSemanticField()" style="width: 100%; margin-bottom: 20px;">Compare Noun Profiles</button>
        
        <div id="semanticGraph"></div>
        
        <!-- Examples panel (hidden by default) -->
        <div id="examplesPanel" style="display: none; margin-top: 20px; padding: 15px; background: white; border: 2px solid #3498db; border-radius: 8px;">
            <h3 id="examplesPanelTitle" style="margin-top: 0;">Examples</h3>
            <div id="examplesList"></div>
        </div>
        
        <div class="snowball-stats">
            <div class="stat-card">
                <h4>Fully Shared</h4>
                <div class="value" id="statFullyShared">-</div>
            </div>
            <div class="stat-card">
                <h4>Partially Shared</h4>
                <div class="value" id="statPartiallyShared">-</div>
            </div>
            <div class="stat-card">
                <h4>Specific</h4>
                <div class="value" id="statSpecific">-</div>
            </div>
        </div>
        
        <div id="semanticDetails" class="results" style="margin-top: 20px;"></div>
    </div>

    <div id="radialModal" class="radial-modal" onclick="closeRadial(event)">
        <div class="radial-content" onclick="event.stopPropagation()">
            <div class="radial-header">
                <div class="radial-title" id="radialTitle">Radial Plot</div>
                <button class="radial-close" onclick="closeRadial(event)">âœ•</button>
            </div>
            <div class="radial-subtitle" id="radialSubtitle"></div>
            <svg id="radialSvg" width="840" height="520"></svg>
            <div class="radial-legend" id="radialLegend"></div>
        </div>
    </div>

    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script>
        let activeFilters = { noun: true, verb: true, adj: true, adv: true };
        let currentWord = '';
        let currentTab = 'sketch';

        async function search() {
            const word = document.getElementById('wordInput').value.trim();
            const apiUrl = document.getElementById('apiUrl').value.trim();
            const resultsDiv = document.getElementById('results');
            const btn = document.getElementById('searchBtn');

            if (!word) return;

            currentWord = word;
            btn.disabled = true;
            resultsDiv.innerHTML = '<div class="loading">Analyzing "' + word + '"...</div>';

            try {
                // Try different API endpoints
                let data = null;
                let errorMsg = '';

                // Try the sketch API
                try {
                    const response = await fetch(`${apiUrl}/api/sketch/${word}`);
                    if (response.ok) {
                        data = await response.json();
                    } else {
                        errorMsg = `API returned ${response.status}`;
                    }
                } catch (e) {
                    errorMsg = e.message;
                }

                // Fallback: try the problem endpoint
                if (!data) {
                    try {
                        const response = await fetch(`${apiUrl}/api/sketch/problem?pos=noun`);
                        if (response.ok) {
                            data = await response.json();
                        }
                    } catch (e) {}
                }

                if (!data) {
                    resultsDiv.innerHTML = `
                        <div class="error">
                            <strong>Could not connect to API</strong><br>
                            Make sure the server is running at: ${apiUrl}<br>
                            <small>${errorMsg}</small>
                        </div>
                    `;
                } else {
                    renderResults(data);
                }
            } catch (e) {
                resultsDiv.innerHTML = `<div class="error">Error: ${e.message}</div>`;
            }

            btn.disabled = false;
        }

        function filterPos(pos) {
            activeFilters[pos] = !activeFilters[pos];
            if (currentWord) {
                search();
            }
        }

        let currentSketchData = null;
        let currentSemanticData = null;
        let currentSemanticAdjMap = {};

        function renderResults(data) {
            const resultsDiv = document.getElementById('results');
            currentSketchData = data;

            if (!data || !data.patterns || Object.keys(data.patterns).length === 0) {
                resultsDiv.innerHTML = `
                    <div class="error">
                        <strong>No results found</strong><br>
                        Try a different word or check the API response.
                    </div>
                `;
                return;
            }

            let html = '';

            // Process patterns from the API
            const patterns = data.patterns;
            
            for (const [patternId, patternData] of Object.entries(patterns)) {
                if (patternData.error) {
                    continue; // Skip patterns with errors
                }
                
                const collocations = patternData.collocations || [];
                if (collocations.length === 0) {
                    continue;
                }
                
                // Determine POS from pattern
                const posGroup = patternData.pos_group || '';
                if (!activeFilters[posGroup]) {
                    continue;
                }
                
                // Render section
                html += `
                    <div class="sketch-section">
                        <h3>
                            ${patternData.name}
                            <span class="pos-tag">${posGroup.toUpperCase()}</span>
                            <button class="radial-button" onclick="openRadialSketch('${patternId}')">Radial view</button>
                        </h3>
                        <div class="collocation-list">
                `;
                
                collocations.slice(0, 15).forEach(c => {
                    const score = c.logDice ? c.logDice.toFixed(2) : '-';
                    const freq = c.frequency || '-';
                    const word = c.lemma || '-';
                    html += `
                        <div class="collocation">
                            <span class="word">${escapeHtml(word)}</span>
                            <span>
                                <span class="score">logDice: ${score}</span>
                                <span class="freq">(${freq})</span>
                            </span>
                        </div>
                    `;
                });
                
                html += '</div>';
                
                // Render examples if available
                const firstWithExamples = collocations.find(c => c.examples && c.examples.length > 0);
                if (firstWithExamples && firstWithExamples.examples.length > 0) {
                    html += '<div class="examples"><h4>Examples</h4>';
                    firstWithExamples.examples.slice(0, 5).forEach(ex => {
                        const highlighted = escapeHtml(ex).replace(
                            new RegExp(escapeRegExp(currentWord), 'gi'),
                            '<span class="highlight">$&</span>'
                        );
                        html += `<div class="example">${highlighted}</div>`;
                    });
                    html += '</div>';
                }
                
                html += '</div>';
            }

            if (html === '') {
                html = '<div class="error">No collocations found for the selected filters.</div>';
            }

            resultsDiv.innerHTML = html;
        }

        function escapeHtml(str) {
            if (!str) return '';
            return String(str)
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;');
        }

        function escapeRegExp(str) {
            return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        }

        function escapeJs(str) {
            return String(str)
                .replace(/\\/g, '\\\\')
                .replace(/'/g, "\\'");
        }

        function openRadialSketch(patternId) {
            if (!currentSketchData || !currentSketchData.patterns) return;
            const pattern = currentSketchData.patterns[patternId];
            if (!pattern || !pattern.collocations) return;

            const items = pattern.collocations.slice(0, 28).map(c => ({
                label: c.lemma,
                score: c.logDice || 0,
                meta: `freq ${c.frequency || 0}`,
                color: '#4a90d9'
            }));

            showRadialPlot({
                title: `${currentWord || 'Word'} â€¢ ${pattern.name}`,
                subtitle: `Pattern: ${pattern.cql}`,
                centerLabel: currentWord || 'word',
                items
            });
        }

        function openRadialAdjective(adjWord) {
            if (!adjWord) return;
            const adj = currentSemanticAdjMap[adjWord.toLowerCase()];
            if (!adj || !currentSemanticData) return;

            const nouns = currentSemanticData.nouns || [];
            const scores = adj.noun_scores || {};
            const items = nouns.map(noun => ({
                label: noun,
                score: scores[noun] || 0,
                meta: scores[noun] ? `logDice ${scores[noun].toFixed(2)}` : 'no match',
                color: '#d94a4a'
            }));

            showRadialPlot({
                title: `${adj.word} â€¢ noun profile`,
                subtitle: `Category: ${adj.category} â€¢ present in ${adj.present_in}/${adj.total_nouns}`,
                centerLabel: adj.word,
                items
            });
        }

        function showRadialPlot({ title, subtitle, centerLabel, items }) {
            const modal = document.getElementById('radialModal');
            const svg = document.getElementById('radialSvg');
            const legend = document.getElementById('radialLegend');

            document.getElementById('radialTitle').textContent = title || 'Radial Plot';
            document.getElementById('radialSubtitle').textContent = subtitle || '';

            const width = svg.clientWidth || 840;
            const height = svg.clientHeight || 520;
            svg.setAttribute('width', width);
            svg.setAttribute('height', height);
            svg.innerHTML = '';
            legend.innerHTML = '';

            const centerX = width / 2;
            const centerY = height / 2;
            const baseRadius = 80;
            const maxRadius = Math.min(width, height) / 2 - 60;

            const maxScore = Math.max(1, ...items.map(i => i.score || 0));
            const angleStep = (Math.PI * 2) / Math.max(1, items.length);

            const ns = 'http://www.w3.org/2000/svg';

            // Center node
            const centerCircle = document.createElementNS(ns, 'circle');
            centerCircle.setAttribute('cx', centerX);
            centerCircle.setAttribute('cy', centerY);
            centerCircle.setAttribute('r', 26);
            centerCircle.setAttribute('fill', '#4a90d9');
            svg.appendChild(centerCircle);

            const centerText = document.createElementNS(ns, 'text');
            centerText.setAttribute('x', centerX);
            centerText.setAttribute('y', centerY + 5);
            centerText.setAttribute('text-anchor', 'middle');
            centerText.setAttribute('font-size', '12');
            centerText.setAttribute('fill', '#fff');
            centerText.textContent = centerLabel || 'center';
            svg.appendChild(centerText);

            items.forEach((item, idx) => {
                const angle = idx * angleStep - Math.PI / 2;
                const strength = (item.score || 0) / maxScore;
                const radius = baseRadius + strength * (maxRadius - baseRadius);
                const x = centerX + Math.cos(angle) * radius;
                const y = centerY + Math.sin(angle) * radius;

                const line = document.createElementNS(ns, 'line');
                line.setAttribute('x1', centerX);
                line.setAttribute('y1', centerY);
                line.setAttribute('x2', x);
                line.setAttribute('y2', y);
                line.setAttribute('stroke', '#cbd5e1');
                line.setAttribute('stroke-width', Math.max(1, 1 + strength * 3));
                svg.appendChild(line);

                const dot = document.createElementNS(ns, 'circle');
                dot.setAttribute('cx', x);
                dot.setAttribute('cy', y);
                dot.setAttribute('r', 6 + strength * 6);
                dot.setAttribute('fill', item.color || '#4a90d9');
                svg.appendChild(dot);

                const label = document.createElementNS(ns, 'text');
                label.setAttribute('x', x + (x > centerX ? 10 : -10));
                label.setAttribute('y', y + 4);
                label.setAttribute('text-anchor', x > centerX ? 'start' : 'end');
                label.setAttribute('font-size', '12');
                label.textContent = item.label;
                svg.appendChild(label);
            });

            const legendItems = [
                { label: `max logDice ${maxScore.toFixed(2)}`, color: '#4a90d9' }
            ];
            legendItems.forEach(item => {
                const span = document.createElement('span');
                const dot = document.createElement('span');
                dot.className = 'dot';
                dot.style.background = item.color;
                span.appendChild(dot);
                span.appendChild(document.createTextNode(item.label));
                legend.appendChild(span);
            });

            modal.classList.add('active');
        }

        function closeRadial(event) {
            if (event) {
                event.preventDefault();
            }
            document.getElementById('radialModal').classList.remove('active');
        }

        function switchTab(tabName) {
            currentTab = tabName;
            
            // Update tab buttons
            document.querySelectorAll('.tab').forEach(tab => {
                tab.classList.remove('active');
            });
            event.target.classList.add('active');
            
            // Update tab content
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });
            document.getElementById(tabName + 'Tab').classList.add('active');
        }

        async function runSemanticField() {
            const nouns = document.getElementById('semanticNouns').value.trim();
            const minLogDice = document.getElementById('semanticMinLogDice').value;
            const maxPerNoun = document.getElementById('semanticMaxPerNoun').value;
            const apiUrl = document.getElementById('apiUrl').value.trim();
            
            if (!nouns) {
                alert('Please enter nouns to compare (e.g., theory, model, hypothesis)');
                return;
            }
            
            document.getElementById('semanticGraph').innerHTML = '<div class="loading">Comparing noun profiles...</div>';
            document.getElementById('semanticDetails').innerHTML = '';
            
            try {
                const url = `${apiUrl}/api/semantic-field?nouns=${encodeURIComponent(nouns)}&min_logdice=${minLogDice}&max_per_noun=${maxPerNoun}`;
                const response = await fetch(url);
                
                if (!response.ok) {
                    throw new Error(`API returned ${response.status}`);
                }
                
                const data = await response.json();
                
                // Update stats
                document.getElementById('statFullyShared').textContent = data.fully_shared || 0;
                document.getElementById('statPartiallyShared').textContent = data.partially_shared || 0;
                document.getElementById('statSpecific').textContent = data.specific || 0;
                
                // Visualize graph
                visualizeSemanticField(data);
                
                // Show details panel with graded comparison
                renderSemanticDetails(data);
                
            } catch (e) {
                document.getElementById('semanticGraph').innerHTML = `
                    <div class="error">
                        <strong>Semantic field comparison failed</strong><br>
                        ${e.message}<br>
                        <small>Make sure the API server is running at: ${apiUrl}</small>
                    </div>
                `;
            }
        }

        function renderSemanticDetails(data) {
            const detailsDiv = document.getElementById('semanticDetails');
            const nouns = data.nouns || [];

            currentSemanticData = data;
            currentSemanticAdjMap = {};
            (data.adjectives || []).forEach(adj => {
                if (adj.word) {
                    currentSemanticAdjMap[adj.word.toLowerCase()] = adj;
                }
            });
            
            let html = '';
            
            // Fully shared adjectives
            const fullyShared = (data.adjectives || []).filter(a => a.category === 'fully_shared');
            if (fullyShared.length > 0) {
                html += '<div class="sketch-section"><h3>ðŸŸ¢ Fully Shared (all nouns)</h3>';
                html += renderComparisonTable(fullyShared, nouns);
                html += '</div>';
            }
            
            // Partially shared adjectives  
            const partiallyShared = (data.adjectives || []).filter(a => a.category === 'partially_shared');
            if (partiallyShared.length > 0) {
                html += '<div class="sketch-section"><h3>ðŸŸ¡ Partially Shared (2+ nouns)</h3>';
                html += renderComparisonTable(partiallyShared, nouns);
                html += '</div>';
            }
            
            // Specific adjectives - group by noun
            const specific = (data.adjectives || []).filter(a => a.category === 'specific');
            if (specific.length > 0) {
                html += '<div class="sketch-section"><h3>ðŸ”µ Specific (one noun only)</h3>';
                
                // Group by the noun they're specific to
                const byNoun = {};
                for (const adj of specific) {
                    const noun = adj.specific_to || '?';
                    if (!byNoun[noun]) byNoun[noun] = [];
                    byNoun[noun].push(adj);
                }
                
                for (const noun of nouns) {
                    if (byNoun[noun] && byNoun[noun].length > 0) {
                        html += `<h4 style="margin: 15px 0 5px 0; color: #666;">Specific to "${noun}":</h4>`;
                        byNoun[noun].slice(0, 10).forEach(adj => {
                            const score = adj.max_logdice || 0;
                            html += `
                                <div class="collocation">
                                    <span class="word">${escapeHtml(adj.word)}</span>
                                    <span class="score">logDice: ${score.toFixed(1)}</span>
                                </div>
                            `;
                        });
                    }
                }
                html += '</div>';
            }
            
            if (!html) {
                html = '<div class="error">No adjectives found. Try lowering min_logdice.</div>';
            }
            
            detailsDiv.innerHTML = html;
        }
        
        function renderComparisonTable(adjectives, nouns) {
            let html = '<table style="width: 100%; border-collapse: collapse; font-size: 14px;">';
            html += '<tr style="background: #f5f5f5;"><th style="text-align: left; padding: 8px;">Adjective</th>';
            for (const noun of nouns) {
                html += `<th style="padding: 8px; text-align: center;">${escapeHtml(noun)}</th>`;
            }
            html += '</tr>';
            
            adjectives.slice(0, 20).forEach(adj => {
                const adjSafe = escapeJs(adj.word || '');
                html += `<tr class="adj-row" onclick="openRadialAdjective('${adjSafe}')" style="border-bottom: 1px solid #eee;">`;
                html += `<td style="padding: 8px; font-weight: 500;">${escapeHtml(adj.word)}</td>`;
                
                const scores = adj.noun_scores || {};
                for (const noun of nouns) {
                    const score = scores[noun] || 0;
                    const intensity = score > 0 ? Math.min(1, score / 10) : 0;
                    const bgColor = score > 0 
                        ? `rgba(74, 144, 217, ${intensity * 0.3})` 
                        : '#f9f9f9';
                    html += `<td style="padding: 8px; text-align: center; background: ${bgColor};">`;
                    html += score > 0 ? score.toFixed(1) : '-';
                    html += '</td>';
                }
                html += '</tr>';
            });
            
            html += '</table>';
            return html;
        }

        async function fetchExamples(adjective, noun) {
            // Ensure we have valid adjective and noun (not objects)
            const adj = typeof adjective === 'object' ? adjective.id : adjective;
            const n = typeof noun === 'object' ? noun.id : noun;
            
            // Hide panel during loading
            const panel = document.getElementById('examplesPanel');
            const titleEl = document.getElementById('examplesPanelTitle');
            const listEl = document.getElementById('examplesList');
            
            titleEl.textContent = `Examples: "${adj}" + "${n}" (loading...)`;
            listEl.innerHTML = '<div class="loading">Fetching examples...</div>';
            panel.style.display = 'block';
            
            try {
                const url = `${apiUrl}/api/semantic-field/examples?adjective=${encodeURIComponent(adj)}&noun=${encodeURIComponent(n)}&max=10`;
                const response = await fetch(url);
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json();
                
                // Update title
                titleEl.textContent = `Examples: "${adj}" + "${n}" (${data.count} found)`;
                
                // Display examples
                if (data.examples && data.examples.length > 0) {
                    listEl.innerHTML = data.examples.map((ex, i) => 
                        `<div style="margin: 8px 0; padding: 8px; background: #f8f9fa; border-radius: 4px;">
                            <strong>${i + 1}.</strong> ${highlightWords(ex, adj, n)}
                        </div>`
                    ).join('');
                } else {
                    listEl.innerHTML = '<div style="color: #999;">No examples found for this combination.</div>';
                }
                
            } catch (error) {
                titleEl.textContent = `Examples: "${adj}" + "${n}" (error)`;
                listEl.innerHTML = `<div class="error">Failed to fetch examples: ${error.message}</div>`;
            }
        }

        function highlightWords(sentence, word1, word2) {
            // Simple highlighting - case-insensitive
            const regex1 = new RegExp(`\\b${word1}\\w*`, 'gi');
            const regex2 = new RegExp(`\\b${word2}\\w*`, 'gi');
            
            return sentence
                .replace(regex1, '<mark style="background: #3498db; color: white; padding: 2px 4px; border-radius: 2px;">$&</mark>')
                .replace(regex2, '<mark style="background: #d94a4a; color: white; padding: 2px 4px; border-radius: 2px;">$&</mark>');
        }

        function visualizeSemanticField(data) {
            const container = document.getElementById('semanticGraph');
            container.innerHTML = '';
            
            const width = container.clientWidth;
            const height = 600;
            
            // Create SVG
            const svg = d3.select('#semanticGraph')
                .append('svg')
                .attr('width', width)
                .attr('height', height);
            
            // Prepare graph data
            const nodes = [];
            const links = [];
            const nounList = data.nouns || [];
            
            // Add nouns as nodes (positioned around center)
            nounList.forEach((noun, i) => {
                nodes.push({
                    id: noun,
                    type: 'noun',
                    isSeed: true
                });
            });
            
            // Add adjectives as nodes - use category for coloring
            (data.adjectives || []).forEach(adj => {
                nodes.push({
                    id: adj.word,
                    type: 'adjective',
                    category: adj.category,
                    presentIn: adj.present_in,
                    totalNouns: adj.total_nouns,
                    commonalityScore: adj.commonality_score
                });
            });
            
            // Add edges as links
            (data.edges || []).forEach(edge => {
                links.push({
                    source: edge.source,
                    target: edge.target,
                    logDice: edge.logDice
                });
            });
            
            // Create force simulation
            const simulation = d3.forceSimulation(nodes)
                .force('link', d3.forceLink(links).id(d => d.id).distance(100))
                .force('charge', d3.forceManyBody().strength(-300))
                .force('center', d3.forceCenter(width / 2, height / 2))
                .force('collision', d3.forceCollide().radius(30));
            
            // Draw links
            const link = svg.append('g')
                .selectAll('line')
                .data(links)
                .join('line')
                .attr('stroke', '#999')
                .attr('stroke-opacity', d => Math.min(1, d.logDice / 10))
                .attr('stroke-width', d => Math.max(1, d.logDice / 3))
                .attr('cursor', 'pointer')
                .on('click', function(event, d) {
                    // Fetch examples when clicking on an edge
                    fetchExamples(d.source.id, d.target.id);
                });
            
            // Draw nodes - color by category
            const node = svg.append('g')
                .selectAll('circle')
                .data(nodes)
                .join('circle')
                .attr('r', d => {
                    if (d.type === 'noun') return 12;
                    // Adjectives sized by presentIn count
                    return 4 + (d.presentIn || 1) * 2;
                })
                .attr('fill', d => {
                    if (d.type === 'noun') {
                        return '#d94a4a';  // Nouns in red
                    }
                    // Color adjectives by category
                    if (d.category === 'fully_shared') return '#2ecc71';   // Green
                    if (d.category === 'partially_shared') return '#f1c40f'; // Yellow
                    return '#3498db';  // Blue for specific
                })
                .attr('stroke', '#fff')
                .attr('stroke-width', 2)
                .attr('cursor', 'pointer')
                .call(d3.drag()
                    .on('start', dragstarted)
                    .on('drag', dragged)
                    .on('end', dragended));
            
            // Add labels
            const label = svg.append('g')
                .selectAll('text')
                .data(nodes)
                .join('text')
                .text(d => d.id)
                .attr('font-size', d => d.type === 'noun' ? 13 : 10)
                .attr('font-weight', d => (d.type === 'noun' || d.category === 'fully_shared') ? 'bold' : 'normal')
                .attr('dx', 12)
                .attr('dy', 4);
            
            // Add tooltips
            node.append('title')
                .text(d => {
                    if (d.type === 'noun') return d.id + ' (noun)';
                    const cat = d.category === 'fully_shared' ? 'all nouns' 
                        : d.category === 'partially_shared' ? 'some nouns' : 'specific';
                    return `${d.id} (${cat}, ${d.presentIn}/${d.totalNouns})`;
                });
            
            // Update positions on tick
            simulation.on('tick', () => {
                link
                    .attr('x1', d => d.source.x)
                    .attr('y1', d => d.source.y)
                    .attr('x2', d => d.target.x)
                    .attr('y2', d => d.target.y);
                
                node
                    .attr('cx', d => d.x)
                    .attr('cy', d => d.y);
                
                label
                    .attr('x', d => d.x)
                    .attr('y', d => d.y);
            });
            
            // Drag functions
            function dragstarted(event) {
                if (!event.active) simulation.alphaTarget(0.3).restart();
                event.subject.fx = event.subject.x;
                event.subject.fy = event.subject.y;
            }
            
            function dragged(event) {
                event.subject.fx = event.x;
                event.subject.fy = event.y;
            }
            
            function dragended(event) {
                if (!event.active) simulation.alphaTarget(0);
                event.subject.fx = null;
                event.subject.fy = null;
            }
        }

        // Enter key to search
        document.getElementById('wordInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') search();
        });
        
        // Enter key for semantic field
        document.getElementById('semanticNouns').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') runSemanticField();
        });
    </script>
</body>
</html>
