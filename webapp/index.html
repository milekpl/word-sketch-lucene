<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Word Sketch Lucene Demo</title>
    <style>
        * { box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: #f5f5f5;
        }
        h1 { color: #333; margin-bottom: 5px; }
        .subtitle { color: #666; margin-bottom: 30px; }
        .search-box {
            display: flex;
            gap: 10px;
            margin-bottom: 30px;
        }
        input[type="text"] {
            flex: 1;
            padding: 12px 16px;
            font-size: 16px;
            border: 2px solid #ddd;
            border-radius: 8px;
        }
        input[type="text"]:focus {
            outline: none;
            border-color: #4a90d9;
        }
        select {
            padding: 12px 16px;
            font-size: 16px;
            border: 2px solid #ddd;
            border-radius: 8px;
            background: white;
        }
        button {
            padding: 12px 24px;
            font-size: 16px;
            background: #4a90d9;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
        }
        button:hover { background: #357abd; }
        button:disabled { background: #ccc; }
        .pos-filters {
            display: flex;
            gap: 8px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        .pos-filters label {
            display: flex;
            align-items: center;
            gap: 4px;
            padding: 8px 12px;
            background: white;
            border-radius: 6px;
            cursor: pointer;
            border: 1px solid #ddd;
        }
        .pos-filters input:checked + span {
            font-weight: bold;
            color: #4a90d9;
        }
        .results { display: grid; gap: 20px; }
        .sketch-section {
            background: white;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        .sketch-section h3 {
            margin: 0 0 15px 0;
            color: #333;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .sketch-section .pos-tag {
            background: #e8f4fd;
            color: #4a90d9;
            padding: 4px 10px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: bold;
        }
        .collocation {
            display: flex;
            justify-content: space-between;
            padding: 8px 12px;
            border-bottom: 1px solid #eee;
        }
        .collocation:last-child { border-bottom: none; }
        .collocation .word { font-weight: 500; }
        .collocation .score {
            color: #666;
            font-size: 14px;
        }
        .collocation .freq { color: #999; font-size: 12px; }
        .examples {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #eee;
        }
        .examples h4 {
            margin: 0 0 10px 0;
            color: #666;
            font-size: 14px;
        }
        .example {
            padding: 8px 12px;
            background: #f9f9f9;
            border-radius: 6px;
            margin-bottom: 8px;
            font-size: 14px;
        }
        .example .highlight {
            background: #fff3cd;
            padding: 0 2px;
            border-radius: 2px;
        }
        .loading {
            text-align: center;
            padding: 40px;
            color: #666;
        }
        .error {
            background: #fee;
            color: #c00;
            padding: 20px;
            border-radius: 8px;
        }
        .api-config {
            background: #fff8e0;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
        }
        .api-config label {
            display: block;
            margin-bottom: 5px;
            font-size: 14px;
        }
        .api-config input {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        .tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            border-bottom: 2px solid #ddd;
        }
        .tab {
            padding: 12px 24px;
            background: none;
            border: none;
            border-bottom: 3px solid transparent;
            cursor: pointer;
            font-size: 16px;
            color: #666;
        }
        .tab.active {
            color: #4a90d9;
            border-bottom-color: #4a90d9;
            font-weight: 500;
        }
        .tab-content {
            display: none;
        }
        .tab-content.active {
            display: block;
        }
        .snowball-controls {
            display: grid;
            grid-template-columns: 2fr 1fr 1fr 1fr;
            gap: 10px;
            margin-bottom: 20px;
        }
        .snowball-controls input,
        .snowball-controls select {
            padding: 12px;
            font-size: 14px;
            border: 2px solid #ddd;
            border-radius: 8px;
        }
        #snowballGraph {
            width: 100%;
            height: 600px;
            background: white;
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        .snowball-stats {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            margin-top: 20px;
        }
        .stat-card {
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        .stat-card h4 {
            margin: 0 0 5px 0;
            color: #666;
            font-size: 12px;
            text-transform: uppercase;
        }
        .stat-card .value {
            font-size: 28px;
            font-weight: bold;
            color: #4a90d9;
        }
        .radial-button {
            margin-left: auto;
            padding: 6px 10px;
            font-size: 12px;
            background: #f0f5ff;
            color: #357abd;
            border: 1px solid #cfe0ff;
            border-radius: 6px;
            cursor: pointer;
        }
        .radial-button:hover { background: #e4efff; }
        .radial-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }
        .radial-modal.active { display: flex; }
        .radial-content {
            background: white;
            border-radius: 12px;
            width: 880px;
            max-width: 95vw;
            padding: 20px;
            box-shadow: 0 8px 30px rgba(0,0,0,0.2);
        }
        .radial-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        .radial-title {
            font-size: 18px;
            font-weight: 600;
            color: #333;
        }
        .radial-subtitle {
            font-size: 13px;
            color: #666;
            margin-bottom: 8px;
        }
        .radial-close {
            background: none;
            border: none;
            font-size: 18px;
            cursor: pointer;
            color: #666;
        }
        .radial-legend {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
            font-size: 12px;
            color: #666;
            margin-top: 8px;
        }
        .radial-legend span {
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }
        .radial-legend .dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            display: inline-block;
        }
        .adj-row { cursor: pointer; }
        .adj-row:hover { background: #f7fbff; }
    </style>
</head>
<body>
    <h1>Word Sketch Lucene</h1>
    <p class="subtitle">Corpus-based collocation analysis powered by Apache Lucene</p>

    <div class="api-config">
        <label>API URL:</label>
        <input type="text" id="apiUrl" value="http://localhost:8080" placeholder="http://localhost:8080">
    </div>

    <div class="tabs">
        <button class="tab active" onclick="switchTab('sketch')">Word Sketch</button>
        <button class="tab" onclick="switchTab('semantic')">Semantic Field Explorer</button>
    </div>

    <div id="sketchTab" class="tab-content active">
        <div class="search-box">
            <input type="text" id="wordInput" placeholder="Enter a word (e.g., 'problem', 'house', 'run')" autofocus>
            <select id="posFilter">
                <option value="">All POS</option>
                <option value="noun">Nouns</option>
                <option value="verb">Verbs</option>
                <option value="adj">Adjectives</option>
                <option value="adv">Adverbs</option>
            </select>
            <button id="searchBtn" onclick="search()">Search</button>
        </div>

        <div class="pos-filters">
            <label><input type="checkbox" checked onchange="filterPos('noun')"> <span>Nouns (n)</span></label>
            <label><input type="checkbox" checked onchange="filterPos('verb')"> <span>Verbs (v)</span></label>
            <label><input type="checkbox" checked onchange="filterPos('adj')"> <span>Adjectives (adj)</span></label>
            <label><input type="checkbox" checked onchange="filterPos('adv')"> <span>Adverbs (adv)</span></label>
        </div>

        <div id="results" class="results"></div>
    </div>

    <div id="semanticTab" class="tab-content">
        <!-- Mode selector -->
        <div class="pos-filters" style="margin-bottom: 15px;">
            <label><input type="radio" name="semanticMode" value="explore" checked onchange="switchSemanticMode('explore')"> <span>Explore (bootstrap from seed)</span></label>
            <label><input type="radio" name="semanticMode" value="multiexplore" onchange="switchSemanticMode('multiexplore')"> <span>Multi-Seed Explore (cluster of seeds)</span></label>
            <label><input type="radio" name="semanticMode" value="compare" onchange="switchSemanticMode('compare')"> <span>Compare (analyze given nouns)</span></label>
        </div>

        <!-- Explore mode (single seed) -->
        <div id="exploreMode" class="snowball-controls" style="grid-template-columns: 2fr 1.5fr 0.7fr 0.7fr 0.7fr 0.5fr;">
            <input type="text" id="exploreSeed" placeholder="Seed word (e.g., house, car, theory)">
            <select id="exploreRelation" title="Grammatical relation">
                <option value="adj_predicate">X is ADJ (predicate)</option>
                <option value="adj_modifier">ADJ X (modifier)</option>
                <option value="subject_of">X VERBs (subject)</option>
                <option value="object_of">VERB X (object)</option>
            </select>
            <input type="number" id="exploreTopAdj" value="15" min="5" max="30" title="Top collocates to use">
            <input type="number" id="exploreMinShared" value="2" min="1" max="5" title="Min shared collocates">
            <input type="number" id="exploreMinLogDice" value="2.0" step="0.5" min="0" title="Min LogDice">
            <button onclick="runExplore()">Explore</button>
        </div>

        <!-- Multi-Seed Explore mode (hidden by default) -->
        <div id="multiexploreMode" class="snowball-controls" style="display: none; grid-template-columns: 2fr 1.5fr 0.7fr 0.7fr 0.7fr 0.5fr;">
            <input type="text" id="multiExploreSeed" placeholder="Seeds (comma-separated, e.g., theory,model,hypothesis)">
            <select id="multiExploreRelation" title="Grammatical relation">
                <option value="adj_predicate">X is ADJ (predicate)</option>
                <option value="adj_modifier">ADJ X (modifier)</option>
                <option value="subject_of">X VERBs (subject)</option>
                <option value="object_of">VERB X (object)</option>
            </select>
            <input type="number" id="multiExploreTopAdj" value="15" min="5" max="30" title="Top collocates per seed">
            <input type="number" id="multiExploreMinShared" value="2" min="1" max="5" title="Min shared collocates">
            <input type="number" id="multiExploreMinLogDice" value="2.0" step="0.5" min="0" title="Min LogDice">
            <button onclick="runMultiExplore()">Explore</button>
        </div>

        <!-- Compare mode (hidden by default) -->
        <div id="compareMode" class="snowball-controls" style="display: none; grid-template-columns: 2fr 0.8fr 0.8fr 0.5fr;">
            <input type="text" id="semanticNouns" placeholder="Nouns to compare (comma-separated, e.g., theory,model,hypothesis)">
            <input type="number" id="semanticMinLogDice" value="2.0" step="0.5" min="0" placeholder="Min LogDice" title="Minimum LogDice threshold">
            <input type="number" id="semanticMaxPerNoun" value="50" min="10" max="100" placeholder="Max per noun" title="Maximum collocates per noun">
            <button onclick="runSemanticField()">Compare</button>
        </div>
        
        <div id="semanticGraph"></div>
        
        <!-- Examples panel (hidden by default) -->
        <div id="examplesPanel" style="display: none; margin-top: 20px; padding: 15px; background: white; border: 2px solid #3498db; border-radius: 8px;">
            <h3 id="examplesPanelTitle" style="margin-top: 0;">Examples</h3>
            <div id="examplesList"></div>
        </div>
        
        <div class="snowball-stats">
            <div class="stat-card">
                <h4 id="statLabel1">Seed Adjectives</h4>
                <div class="value" id="statFullyShared">-</div>
            </div>
            <div class="stat-card">
                <h4 id="statLabel2">Discovered Nouns</h4>
                <div class="value" id="statPartiallyShared">-</div>
            </div>
            <div class="stat-card">
                <h4 id="statLabel3">Core Adjectives</h4>
                <div class="value" id="statSpecific">-</div>
            </div>
        </div>
        
        <div id="semanticDetails" class="results" style="margin-top: 20px;"></div>
    </div>

    <div id="radialModal" class="radial-modal" onclick="closeRadial(event)">
        <div class="radial-content" onclick="event.stopPropagation()">
            <div class="radial-header">
                <div class="radial-title" id="radialTitle">Radial Plot</div>
                <button class="radial-close" onclick="closeRadial(event)">‚úï</button>
            </div>
            <div class="radial-subtitle" id="radialSubtitle"></div>
            <svg id="radialSvg" width="840" height="520"></svg>
            <div class="radial-legend" id="radialLegend"></div>
        </div>
    </div>

    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script>
        let activeFilters = { noun: true, verb: true, adj: true, adv: true };
        let currentWord = '';
        let currentTab = 'sketch';

        async function search() {
            const word = document.getElementById('wordInput').value.trim();
            const apiUrl = document.getElementById('apiUrl').value.trim();
            const resultsDiv = document.getElementById('results');
            const btn = document.getElementById('searchBtn');

            if (!word) return;

            currentWord = word;
            btn.disabled = true;
            resultsDiv.innerHTML = '<div class="loading">Analyzing "' + word + '"...</div>';

            try {
                // Try different API endpoints
                let data = null;
                let errorMsg = '';

                // Try the sketch API
                try {
                    const response = await fetch(`${apiUrl}/api/sketch/${word}`);
                    if (response.ok) {
                        data = await response.json();
                    } else {
                        errorMsg = `API returned ${response.status}`;
                    }
                } catch (e) {
                    errorMsg = e.message;
                }

                // Fallback: try the problem endpoint
                if (!data) {
                    try {
                        const response = await fetch(`${apiUrl}/api/sketch/problem?pos=noun`);
                        if (response.ok) {
                            data = await response.json();
                        }
                    } catch (e) {}
                }

                if (!data) {
                    resultsDiv.innerHTML = `
                        <div class="error">
                            <strong>Could not connect to API</strong><br>
                            Make sure the server is running at: ${apiUrl}<br>
                            <small>${errorMsg}</small>
                        </div>
                    `;
                } else {
                    renderResults(data);
                }
            } catch (e) {
                resultsDiv.innerHTML = `<div class="error">Error: ${e.message}</div>`;
            }

            btn.disabled = false;
        }

        function filterPos(pos) {
            activeFilters[pos] = !activeFilters[pos];
            if (currentWord) {
                search();
            }
        }

        let currentSketchData = null;
        let currentSemanticData = null;
        let currentSemanticAdjMap = {};

        function renderResults(data) {
            const resultsDiv = document.getElementById('results');
            currentSketchData = data;

            if (!data || !data.patterns || Object.keys(data.patterns).length === 0) {
                resultsDiv.innerHTML = `
                    <div class="error">
                        <strong>No results found</strong><br>
                        Try a different word or check the API response.
                    </div>
                `;
                return;
            }

            let html = '';

            // Process patterns from the API
            const patterns = data.patterns;
            
            for (const [patternId, patternData] of Object.entries(patterns)) {
                if (patternData.error) {
                    continue; // Skip patterns with errors
                }
                
                const collocations = patternData.collocations || [];
                if (collocations.length === 0) {
                    continue;
                }
                
                // Determine POS from pattern
                const posGroup = patternData.pos_group || '';
                if (!activeFilters[posGroup]) {
                    continue;
                }
                
                // Render section
                html += `
                    <div class="sketch-section">
                        <h3>
                            ${patternData.name}
                            <span class="pos-tag">${posGroup.toUpperCase()}</span>
                            <button class="radial-button" onclick="openRadialSketch('${patternId}')">Radial view</button>
                        </h3>
                        <div class="collocation-list">
                `;
                
                collocations.slice(0, 15).forEach(c => {
                    const score = c.logDice ? c.logDice.toFixed(2) : '-';
                    const freq = c.frequency || '-';
                    const word = c.lemma || '-';
                    html += `
                        <div class="collocation">
                            <span class="word">${escapeHtml(word)}</span>
                            <span>
                                <span class="score">logDice: ${score}</span>
                                <span class="freq">(${freq})</span>
                            </span>
                        </div>
                    `;
                });
                
                html += '</div>';
                
                // Render examples if available
                const firstWithExamples = collocations.find(c => c.examples && c.examples.length > 0);
                if (firstWithExamples && firstWithExamples.examples.length > 0) {
                    html += '<div class="examples"><h4>Examples</h4>';
                    firstWithExamples.examples.slice(0, 5).forEach(ex => {
                        const highlighted = escapeHtml(ex).replace(
                            new RegExp(escapeRegExp(currentWord), 'gi'),
                            '<span class="highlight">$&</span>'
                        );
                        html += `<div class="example">${highlighted}</div>`;
                    });
                    html += '</div>';
                }
                
                html += '</div>';
            }

            if (html === '') {
                html = '<div class="error">No collocations found for the selected filters.</div>';
            }

            resultsDiv.innerHTML = html;
        }

        function escapeHtml(str) {
            if (!str) return '';
            return String(str)
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;');
        }

        function escapeRegExp(str) {
            return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        }

        function escapeJs(str) {
            return String(str)
                .replace(/\\/g, '\\\\')
                .replace(/'/g, "\\'");
        }

        function openRadialSketch(patternId) {
            if (!currentSketchData || !currentSketchData.patterns) return;
            const pattern = currentSketchData.patterns[patternId];
            if (!pattern || !pattern.collocations) return;

            const items = pattern.collocations.slice(0, 28).map(c => ({
                label: c.lemma,
                score: c.logDice || 0,
                meta: `freq ${c.frequency || 0}`,
                color: '#4a90d9'
            }));

            showRadialPlot({
                title: `${currentWord || 'Word'} ‚Ä¢ ${pattern.name}`,
                subtitle: `Pattern: ${pattern.cql}`,
                centerLabel: currentWord || 'word',
                items
            });
        }

        function openRadialAdjective(adjWord) {
            if (!adjWord) return;
            const adj = currentSemanticAdjMap[adjWord.toLowerCase()];
            if (!adj || !currentSemanticData) return;

            const nouns = currentSemanticData.nouns || [];
            const scores = adj.noun_scores || {};
            const items = nouns.map(noun => ({
                label: noun,
                score: scores[noun] || 0,
                meta: scores[noun] ? `logDice ${scores[noun].toFixed(2)}` : 'no match',
                color: '#d94a4a'
            }));

            showRadialPlot({
                title: `${adj.word} ‚Ä¢ noun profile`,
                subtitle: `Category: ${adj.category} ‚Ä¢ present in ${adj.present_in}/${adj.total_nouns}`,
                centerLabel: adj.word,
                items
            });
        }

        function showRadialPlot({ title, subtitle, centerLabel, items }) {
            const modal = document.getElementById('radialModal');
            const svg = document.getElementById('radialSvg');
            const legend = document.getElementById('radialLegend');

            document.getElementById('radialTitle').textContent = title || 'Radial Plot';
            document.getElementById('radialSubtitle').textContent = subtitle || '';

            const width = svg.clientWidth || 840;
            const height = svg.clientHeight || 520;
            svg.setAttribute('width', width);
            svg.setAttribute('height', height);
            svg.innerHTML = '';
            legend.innerHTML = '';

            const centerX = width / 2;
            const centerY = height / 2;
            const baseRadius = 80;
            const maxRadius = Math.min(width, height) / 2 - 60;

            const maxScore = Math.max(1, ...items.map(i => i.score || 0));
            const angleStep = (Math.PI * 2) / Math.max(1, items.length);

            const ns = 'http://www.w3.org/2000/svg';

            // Center node
            const centerCircle = document.createElementNS(ns, 'circle');
            centerCircle.setAttribute('cx', centerX);
            centerCircle.setAttribute('cy', centerY);
            centerCircle.setAttribute('r', 26);
            centerCircle.setAttribute('fill', '#4a90d9');
            svg.appendChild(centerCircle);

            const centerText = document.createElementNS(ns, 'text');
            centerText.setAttribute('x', centerX);
            centerText.setAttribute('y', centerY + 5);
            centerText.setAttribute('text-anchor', 'middle');
            centerText.setAttribute('font-size', '12');
            centerText.setAttribute('fill', '#fff');
            centerText.textContent = centerLabel || 'center';
            svg.appendChild(centerText);

            items.forEach((item, idx) => {
                const angle = idx * angleStep - Math.PI / 2;
                const strength = (item.score || 0) / maxScore;
                const radius = baseRadius + strength * (maxRadius - baseRadius);
                const x = centerX + Math.cos(angle) * radius;
                const y = centerY + Math.sin(angle) * radius;

                const line = document.createElementNS(ns, 'line');
                line.setAttribute('x1', centerX);
                line.setAttribute('y1', centerY);
                line.setAttribute('x2', x);
                line.setAttribute('y2', y);
                line.setAttribute('stroke', '#cbd5e1');
                line.setAttribute('stroke-width', Math.max(1, 1 + strength * 3));
                svg.appendChild(line);

                const dot = document.createElementNS(ns, 'circle');
                dot.setAttribute('cx', x);
                dot.setAttribute('cy', y);
                dot.setAttribute('r', 6 + strength * 6);
                dot.setAttribute('fill', item.color || '#4a90d9');
                svg.appendChild(dot);

                const label = document.createElementNS(ns, 'text');
                label.setAttribute('x', x + (x > centerX ? 10 : -10));
                label.setAttribute('y', y + 4);
                label.setAttribute('text-anchor', x > centerX ? 'start' : 'end');
                label.setAttribute('font-size', '12');
                label.textContent = item.label;
                svg.appendChild(label);
            });

            const legendItems = [
                { label: `max logDice ${maxScore.toFixed(2)}`, color: '#4a90d9' }
            ];
            legendItems.forEach(item => {
                const span = document.createElement('span');
                const dot = document.createElement('span');
                dot.className = 'dot';
                dot.style.background = item.color;
                span.appendChild(dot);
                span.appendChild(document.createTextNode(item.label));
                legend.appendChild(span);
            });

            modal.classList.add('active');
        }

        function closeRadial(event) {
            if (event) {
                event.preventDefault();
            }
            document.getElementById('radialModal').classList.remove('active');
        }

        function switchTab(tabName) {
            currentTab = tabName;
            
            // Update tab buttons
            document.querySelectorAll('.tab').forEach(tab => {
                tab.classList.remove('active');
            });
            event.target.classList.add('active');
            
            // Update tab content
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });
            document.getElementById(tabName + 'Tab').classList.add('active');
        }

        function switchSemanticMode(mode) {
            document.getElementById('exploreMode').style.display = mode === 'explore' ? 'flex' : 'none';
            document.getElementById('multiexploreMode').style.display = mode === 'multiexplore' ? 'flex' : 'none';
            document.getElementById('compareMode').style.display = mode === 'compare' ? 'flex' : 'none';
            
            // Update stat labels based on mode
            if (mode === 'explore' || mode === 'multiexplore') {
                document.getElementById('statLabel1').textContent = 'Seed Adjectives';
                document.getElementById('statLabel2').textContent = 'Discovered Nouns';
                document.getElementById('statLabel3').textContent = 'Core Adjectives';
            } else {
                document.getElementById('statLabel1').textContent = 'Fully Shared';
                document.getElementById('statLabel2').textContent = 'Partially Shared';
                document.getElementById('statLabel3').textContent = 'Specific';
            }
        }

        async function runExplore() {
            const seed = document.getElementById('exploreSeed').value.trim();
            const relation = document.getElementById('exploreRelation')?.value || 'adj_predicate';
            const topAdj = document.getElementById('exploreTopAdj')?.value || 15;
            const minShared = document.getElementById('exploreMinShared')?.value || 2;
            const minLogDice = document.getElementById('exploreMinLogDice')?.value || 2;
            const apiUrl = document.getElementById('apiUrl').value.trim();
            
            if (!seed) {
                alert('Please enter a seed word (e.g., house, car, theory)');
                return;
            }
            
            console.log('Exploring:', {seed, relation, topAdj, minShared, minLogDice});
            
            const relationLabels = {
                'adj_predicate': 'X is ADJ',
                'adj_modifier': 'ADJ X',
                'subject_of': 'X VERBs',
                'object_of': 'VERB X'
            };
            const relLabel = relationLabels[relation] || relation;
            document.getElementById('semanticGraph').innerHTML = '<div class="loading">Exploring semantic field from "' + seed + '" (' + relLabel + ')...</div>';
            document.getElementById('semanticDetails').innerHTML = '';
            
            try {
                const url = `${apiUrl}/api/semantic-field/explore?seed=${encodeURIComponent(seed)}&relation=${relation}&top=${topAdj}&min_shared=${minShared}&min_logdice=${minLogDice}`;
                const response = await fetch(url);
                
                if (!response.ok) {
                    throw new Error(`API returned ${response.status}`);
                }
                
                const data = await response.json();
                
                // Update stat labels based on relation type
                const collocateLabel = (relation === 'subject_of' || relation === 'object_of') ? 'Verbs' : 'Adjectives';
                document.getElementById('statLabel1').textContent = `Seed ${collocateLabel}`;
                document.getElementById('statLabel3').textContent = `Core ${collocateLabel}`;
                
                // Update stats
                document.getElementById('statFullyShared').textContent = data.seed_collocates_count || data.seed_adjectives_count || 0;
                document.getElementById('statPartiallyShared').textContent = data.discovered_nouns_count || 0;
                document.getElementById('statSpecific').textContent = data.core_collocates_count || data.core_adjectives_count || 0;
                
                // Visualize exploration results
                visualizeExploration(data, relation);
                
                // Show details panel
                renderExplorationDetails(data);
                
            } catch (e) {
                console.error('Exploration error:', e);
                document.getElementById('semanticGraph').innerHTML = `
                    <div class="error">
                        <strong>Semantic field exploration failed</strong><br>
                        ${e.message}<br>
                        <small>Make sure the API server is running at: ${apiUrl}</small>
                        <small style="display:block; margin-top:5px; color:#999;">Check browser console for details.</small>
                    </div>
                `;
            }
        }

        async function runMultiExplore() {
            const seedsInput = document.getElementById('multiExploreSeed').value.trim();
            const relation = document.getElementById('multiExploreRelation')?.value || 'adj_predicate';
            const topAdj = document.getElementById('multiExploreTopAdj')?.value || 15;
            const minShared = document.getElementById('multiExploreMinShared')?.value || 2;
            const minLogDice = document.getElementById('multiExploreMinLogDice')?.value || 2;
            const apiUrl = document.getElementById('apiUrl').value.trim();
            
            if (!seedsInput) {
                alert('Please enter seed words (comma-separated, e.g., theory,model,hypothesis)');
                return;
            }
            
            const seeds = seedsInput.split(',').map(s => s.trim().toLowerCase()).filter(s => s);
            if (seeds.length < 2) {
                alert('Please enter at least 2 seed words');
                return;
            }
            
            console.log('Multi-exploring:', {seeds, relation, topAdj, minShared, minLogDice});
            
            const relationLabels = {
                'adj_predicate': 'X is ADJ',
                'adj_modifier': 'ADJ X',
                'subject_of': 'X VERBs',
                'object_of': 'VERB X'
            };
            const relLabel = relationLabels[relation] || relation;
            document.getElementById('semanticGraph').innerHTML = '<div class="loading">Exploring semantic field from ' + seeds.length + ' seeds (' + relLabel + ')...</div>';
            document.getElementById('semanticDetails').innerHTML = '';
            
            try {
                const seedsParam = seeds.join(',');
                const url = `${apiUrl}/api/semantic-field/explore-multi?seeds=${encodeURIComponent(seedsParam)}&relation=${relation}&top=${topAdj}&min_shared=${minShared}&min_logdice=${minLogDice}`;
                const response = await fetch(url);
                
                if (!response.ok) {
                    throw new Error(`API returned ${response.status}`);
                }
                
                const data = await response.json();
                
                // Update stat labels based on relation type
                const collocateLabel = (relation === 'subject_of' || relation === 'object_of') ? 'Verbs' : 'Adjectives';
                document.getElementById('statLabel1').textContent = `Seed ${collocateLabel}`;
                document.getElementById('statLabel3').textContent = `Core ${collocateLabel}`;
                
                // Update stats
                document.getElementById('statFullyShared').textContent = data.common_collocates_count || 0;
                document.getElementById('statPartiallyShared').textContent = data.seed_collocates_count || 0;
                document.getElementById('statSpecific').textContent = data.discovered_nouns_count || 0;
                
                // Visualize multi-seed results
                visualizeMultiExploration(data, relation, seeds);
                
                // Show details panel
                renderMultiExplorationDetails(data, seeds);
                
            } catch (e) {
                console.error('Multi-exploration error:', e);
                document.getElementById('semanticGraph').innerHTML = `
                    <div class="error">
                        <strong>Multi-seed exploration failed</strong><br>
                        ${e.message}<br>
                        <small>Make sure the API server is running at: ${apiUrl}</small>
                        <small style="display:block; margin-top:5px; color:#999;">Check browser console for details.</small>
                    </div>
                `;
            }
        }

        function visualizeExploration(data, relation) {
            const graphDiv = document.getElementById('semanticGraph');
            const isVerb = relation === 'subject_of' || relation === 'object_of';
            const collocateType = isVerb ? 'verb' : 'adjective';
            
            // Build nodes and links for force-directed graph
            const nodes = [];
            const links = [];
            const nodeMap = {};
            
            // Seed node (center)
            const seedNode = { id: data.seed, type: 'seed', group: 0 };
            nodes.push(seedNode);
            nodeMap[data.seed] = seedNode;
            
            // Collocate nodes (from seed) - use seed_collocates or fallback to seed_adjectives
            const seedCollocates = data.seed_collocates || data.seed_adjectives || [];
            seedCollocates.slice(0, 12).forEach((coll, i) => {
                const node = { id: coll.word, type: collocateType, group: 1, logDice: coll.logDice };
                nodes.push(node);
                nodeMap[coll.word] = node;
                links.push({ source: data.seed, target: coll.word, weight: Math.log(coll.logDice) / 5 });
            });
            
            // Discovered noun nodes
            (data.discovered_nouns || []).slice(0, 15).forEach((noun, i) => {
                const node = { id: noun.word, type: 'discovered', group: 2, shared: noun.shared_count, score: noun.similarity_score };
                nodes.push(node);
                nodeMap[noun.word] = node;
                
                // Link to shared collocates
                const sharedCollocates = noun.shared_collocates || noun.shared_adjectives || [];
                sharedCollocates.forEach(coll => {
                    if (nodeMap[coll]) {
                        links.push({ source: coll, target: noun.word, weight: 0.5, dashed: true });
                    }
                });
            });
            
            // Core collocate highlighting
            const coreCollocates = new Set((data.core_collocates || data.core_adjectives || []).map(a => a.word));
            
            // Create SVG
            const width = 840;
            const height = 400;
            
            graphDiv.innerHTML = '';
            const svg = d3.select(graphDiv).append('svg')
                .attr('width', width)
                .attr('height', height)
                .style('background', '#fafafa')
                .style('border-radius', '8px');
            
            // Force simulation
            const simulation = d3.forceSimulation(nodes)
                .force('link', d3.forceLink(links).id(d => d.id).distance(d => 80 - d.weight * 10))
                .force('charge', d3.forceManyBody().strength(-200))
                .force('center', d3.forceCenter(width / 2, height / 2))
                .force('collision', d3.forceCollide().radius(30));
            
            // Draw links
            const link = svg.append('g')
                .selectAll('line')
                .data(links)
                .join('line')
                .attr('stroke', d => d.dashed ? '#ccc' : '#999')
                .attr('stroke-opacity', d => d.dashed ? 0.4 : 0.6)
                .attr('stroke-width', d => d.weight + 1)
                .attr('stroke-dasharray', d => d.dashed ? '4,4' : null);
            
            // Draw nodes
            const node = svg.append('g')
                .selectAll('g')
                .data(nodes)
                .join('g')
                .call(d3.drag()
                    .on('start', (event, d) => { if (!event.active) simulation.alphaTarget(0.3).restart(); d.fx = d.x; d.fy = d.y; })
                    .on('drag', (event, d) => { d.fx = event.x; d.fy = event.y; })
                    .on('end', (event, d) => { if (!event.active) simulation.alphaTarget(0); d.fx = null; d.fy = null; }));
            
            // Node circles
            node.append('circle')
                .attr('r', d => d.type === 'seed' ? 20 : (d.type === 'adjective' || d.type === 'verb') ? 12 : 15)
                .attr('fill', d => {
                    if (d.type === 'seed') return '#e74c3c';
                    if (d.type === 'adjective' || d.type === 'verb') return coreCollocates.has(d.id) ? '#27ae60' : '#9b59b6';
                    return '#3498db';
                })
                .attr('stroke', '#fff')
                .attr('stroke-width', 2);
            
            // Node labels
            node.append('text')
                .text(d => d.id)
                .attr('dy', d => d.type === 'seed' ? 35 : 25)
                .attr('text-anchor', 'middle')
                .attr('font-size', d => d.type === 'seed' ? '14px' : '11px')
                .attr('font-weight', d => d.type === 'seed' ? 'bold' : 'normal')
                .attr('fill', '#333');
            
            // Shared count badge for discovered nouns
            node.filter(d => d.type === 'discovered')
                .append('text')
                .text(d => d.shared)
                .attr('dy', 4)
                .attr('text-anchor', 'middle')
                .attr('font-size', '10px')
                .attr('font-weight', 'bold')
                .attr('fill', '#fff');
            
            // Simulation tick
            simulation.on('tick', () => {
                link
                    .attr('x1', d => d.source.x)
                    .attr('y1', d => d.source.y)
                    .attr('x2', d => d.target.x)
                    .attr('y2', d => d.target.y);
                node.attr('transform', d => `translate(${d.x},${d.y})`);
            });
            
            // Legend - dynamic based on relation type
            const collocateLabel = isVerb ? 'verb' : 'adjective';
            const legend = document.createElement('div');
            legend.className = 'radial-legend';
            legend.innerHTML = `
                <span><span class="dot" style="background:#e74c3c"></span>Seed word</span>
                <span><span class="dot" style="background:#27ae60"></span>Core ${collocateLabel}</span>
                <span><span class="dot" style="background:#9b59b6"></span>Seed ${collocateLabel}</span>
                <span><span class="dot" style="background:#3498db"></span>Discovered noun</span>
            `;
            graphDiv.appendChild(legend);
        }

        function renderExplorationDetails(data) {
            const detailsDiv = document.getElementById('semanticDetails');
            const relation = data.relation_type || 'ADJ_PREDICATE';
            const isVerb = relation === 'SUBJECT_OF' || relation === 'OBJECT_OF';
            const collocateLabel = isVerb ? 'verbs' : 'adjectives';
            const collocateLabelCap = isVerb ? 'Verbs' : 'Adjectives';
            const collocateLabelSingular = isVerb ? 'verb' : 'adjective';
            
            // Get collocates - use generic keys or fallback to adjective-specific keys
            const seedCollocates = data.seed_collocates || data.seed_adjectives || [];
            const coreCollocates = data.core_collocates || data.core_adjectives || [];
            const seedCount = data.seed_collocates_count || data.seed_adjectives_count || 0;
            const coreCount = data.core_collocates_count || data.core_adjectives_count || 0;
            
            const relationLabels = {
                'ADJ_PREDICATE': 'X is ADJ',
                'ADJ_MODIFIER': 'ADJ X',
                'SUBJECT_OF': 'X VERBs',
                'OBJECT_OF': 'VERB X'
            };
            const relLabel = relationLabels[relation] || relation;
            
            let html = `
                <div class="sketch-section">
                    <h3>üîç Exploration from "${data.seed}" <span style="font-size:12px; color:#666; font-weight:normal;">(${relLabel})</span></h3>
                    <p style="color:#666; margin-bottom:15px;">
                        Found <strong>${data.discovered_nouns_count}</strong> similar nouns using 
                        <strong>${seedCount}</strong> ${collocateLabel}.
                        <strong>${coreCount}</strong> ${collocateLabel} define the semantic class.
                    </p>
                    
                    <h4 style="margin-top:20px;">Discovered Semantic Class</h4>
                    <p style="color:#888; font-size:13px;">Nouns that share ${collocateLabelSingular} ${relation === 'ADJ_PREDICATE' ? 'predicates' : 'collocations'} with "${data.seed}"</p>
                    <table style="width:100%; border-collapse:collapse; margin-top:10px;">
                        <tr style="background:#f0f0f0;">
                            <th style="text-align:left; padding:8px;">Noun</th>
                            <th style="text-align:center; padding:8px;">Shared</th>
                            <th style="text-align:right; padding:8px;">Score</th>
                            <th style="text-align:left; padding:8px;">Shared ${collocateLabelCap}</th>
                        </tr>
            `;
            
            (data.discovered_nouns || []).slice(0, 20).forEach(noun => {
                const sharedCollocates = noun.shared_collocates || noun.shared_adjectives || [];
                html += `
                    <tr class="collocation" style="cursor:pointer;" onclick="document.getElementById('exploreSeed').value='${noun.word}'; runExplore();">
                        <td style="padding:8px; font-weight:500;">${noun.word}</td>
                        <td style="text-align:center; padding:8px;">
                            <span style="background:#3498db; color:white; padding:2px 8px; border-radius:10px; font-size:12px;">${noun.shared_count}</span>
                        </td>
                        <td style="text-align:right; padding:8px; color:#666;">${noun.similarity_score.toFixed(1)}</td>
                        <td style="padding:8px; font-size:12px; color:#888;">${sharedCollocates.slice(0, 5).join(', ')}${sharedCollocates.length > 5 ? '...' : ''}</td>
                    </tr>
                `;
            });
            
            html += `</table>`;
            
            // Core collocates section
            html += `
                <h4 style="margin-top:25px;">Core ${collocateLabelCap} (Class Definers)</h4>
                <p style="color:#888; font-size:13px;">${collocateLabelCap} shared by many nouns in this semantic class</p>
                <div style="display:flex; flex-wrap:wrap; gap:10px; margin-top:10px;">
            `;
            
            coreCollocates.forEach(coll => {
                const coverage = Math.round(coll.coverage * 100);
                html += `
                    <div style="background:#e8f8f5; border:1px solid #27ae60; border-radius:20px; padding:6px 12px; font-size:13px;">
                        <strong>${coll.word}</strong>
                        <span style="color:#27ae60; margin-left:5px;">${coverage}%</span>
                    </div>
                `;
            });
            
            html += `</div>`;
            
            // Seed collocates section
            html += `
                <h4 style="margin-top:25px;">Seed ${collocateLabelCap} (from "${data.seed}")</h4>
                <div style="display:flex; flex-wrap:wrap; gap:8px; margin-top:10px;">
            `;
            
            seedCollocates.forEach(coll => {
                const isCore = coreCollocates.some(c => c.word === coll.word);
                html += `
                    <span style="background:${isCore ? '#27ae60' : '#9b59b6'}; color:white; padding:4px 10px; border-radius:15px; font-size:12px;">
                        ${coll.word}
                    </span>
                `;
            });
            
            html += `</div></div>`;
            
            detailsDiv.innerHTML = html;
        }

        function visualizeMultiExploration(data, relation, seeds) {
            const graphDiv = document.getElementById('semanticGraph');
            const isVerb = relation === 'subject_of' || relation === 'object_of';
            const collocateType = isVerb ? 'verb' : 'adjective';
            
            // Build nodes and links for force-directed graph
            const nodes = [];
            const links = [];
            const nodeMap = {};
            
            // Seed nodes (cluster in center)
            seeds.forEach((seed, i) => {
                const seedNode = { id: seed, type: 'seed', group: 0 };
                nodes.push(seedNode);
                nodeMap[seed] = seedNode;
            });
            
            // Collocate nodes (adjectives/verbs around seeds)
            if (data.edges) {
                data.edges.forEach(edge => {
                    // Source is seed, target is collocate
                    if (!nodeMap[edge.target]) {
                        const collocNode = { id: edge.target, type: 'collocate', group: 1 };
                        nodes.push(collocNode);
                        nodeMap[edge.target] = collocNode;
                    }
                    links.push({
                        source: edge.source,
                        target: edge.target,
                        value: edge.weight,
                        type: edge.type
                    });
                });
            }
            
            // Create SVG graph (force-directed)
            const width = graphDiv.offsetWidth;
            const height = 600;
            
            graphDiv.innerHTML = `<svg id="graphSvg" width="${width}" height="${height}" style="border: 1px solid #ddd; border-radius: 8px;"></svg>`;
            
            const svg = d3.select('#graphSvg');
            const simulation = d3.forceSimulation(nodes)
                .force('link', d3.forceLink(links).id(d => d.id).distance(60).strength(0.1))
                .force('charge', d3.forceManyBody().strength(-300))
                .force('center', d3.forceCenter(width / 2, height / 2))
                .force('collide', d3.forceCollide(25));
            
            const link = svg.selectAll('line')
                .data(links)
                .enter()
                .append('line')
                .style('stroke', '#999')
                .style('stroke-opacity', 0.6)
                .style('stroke-width', d => Math.log(d.value + 1) * 2);
            
            const node = svg.selectAll('circle')
                .data(nodes)
                .enter()
                .append('circle')
                .attr('r', d => d.type === 'seed' ? 12 : 7)
                .style('fill', d => d.type === 'seed' ? '#FF6B6B' : '#4a90d9')
                .style('stroke', '#fff')
                .style('stroke-width', 2)
                .call(d3.drag()
                    .on('start', dragstarted)
                    .on('drag', dragged)
                    .on('end', dragended));
            
            const text = svg.selectAll('text')
                .data(nodes)
                .enter()
                .append('text')
                .attr('dy', '0.31em')
                .attr('text-anchor', 'middle')
                .text(d => d.id)
                .style('font-size', d => d.type === 'seed' ? '12px' : '10px')
                .style('pointer-events', 'none')
                .style('font-weight', d => d.type === 'seed' ? 'bold' : 'normal');
            
            simulation.on('tick', () => {
                link
                    .attr('x1', d => d.source.x)
                    .attr('y1', d => d.source.y)
                    .attr('x2', d => d.target.x)
                    .attr('y2', d => d.target.y);
                
                node
                    .attr('cx', d => d.x)
                    .attr('cy', d => d.y);
                
                text
                    .attr('x', d => d.x)
                    .attr('y', d => d.y);
            });
            
            function dragstarted(event, d) {
                if (!event.active) simulation.alphaTarget(0.3).restart();
                d.fx = d.x;
                d.fy = d.y;
            }
            
            function dragged(event, d) {
                d.fx = event.x;
                d.fy = event.y;
            }
            
            function dragended(event, d) {
                if (!event.active) simulation.alphaTarget(0);
                d.fx = null;
                d.fy = null;
            }
        }

        function renderMultiExplorationDetails(data, seeds) {
            const detailsDiv = document.getElementById('semanticDetails');
            const relation = data.relation_type || 'ADJ_PREDICATE';
            const isVerb = relation === 'SUBJECT_OF' || relation === 'OBJECT_OF';
            const collocateLabel = isVerb ? 'verbs' : 'adjectives';
            const collocateLabelCap = isVerb ? 'Verbs' : 'Adjectives';
            
            const relationLabels = {
                'ADJ_PREDICATE': 'X is ADJ',
                'ADJ_MODIFIER': 'ADJ X',
                'SUBJECT_OF': 'X VERBs',
                'OBJECT_OF': 'VERB X'
            };
            const relLabel = relationLabels[relation] || relation;
            
            let html = `
                <div class="sketch-section">
                    <h3>üîç Multi-Seed Exploration <span style="font-size:12px; color:#666; font-weight:normal;">(${relLabel})</span></h3>
                    <p style="color:#666; margin-bottom:15px;">
                        <strong>Seeds:</strong> ${seeds.join(', ')} <br>
                        <strong>${collocateLabelCap} found:</strong> ${data.seed_collocates_count || 0} | 
                        <strong>Common across all:</strong> ${data.common_collocates_count || 0}
                    </p>
            `;
            
            // List seed collocates
            if (data.seed_collocates && data.seed_collocates.length > 0) {
                html += `<div style="margin-bottom: 15px;">
                    <h4 style="margin: 0 0 10px 0; color: #333;">Seed ${collocateLabelCap}:</h4>
                    <div>`;
                
                data.seed_collocates.forEach(item => {
                    html += `<div class="collocation">
                        <strong>${item.word}</strong>
                        <span style="color: #666; font-size: 12px;">logDice: ${item.logDice?.toFixed(2) || 'N/A'}</span>
                    </div>`;
                });
                
                html += `</div></div>`;
            }
            
            // List common collocates if any
            if (data.common_collocates && data.common_collocates.length > 0) {
                html += `<div style="margin-bottom: 15px; background: #f0f8ff; padding: 10px; border-radius: 6px; border-left: 4px solid #4a90d9;">
                    <h4 style="margin: 0 0 10px 0; color: #4a90d9;">Common ${collocateLabelCap} (shared by all seeds):</h4>
                    <div>`;
                
                data.common_collocates.forEach(word => {
                    html += `<div class="collocation" style="background: white; margin-bottom: 5px; border-radius: 3px;">
                        <strong>${word}</strong>
                    </div>`;
                });
                
                html += `</div></div>`;
            }
            
            html += `</div>`;
            
            detailsDiv.innerHTML = html;
        }

        async function runSemanticField() {
            const nouns = document.getElementById('semanticNouns')?.value?.trim() || '';
            const minLogDice = document.getElementById('semanticMinLogDice')?.value || 2.0;
            const maxPerNoun = document.getElementById('semanticMaxPerNoun')?.value || 50;
            const apiUrl = document.getElementById('apiUrl').value.trim();
            
            if (!nouns) {
                alert('Please enter nouns to compare (comma-separated, e.g., theory, model, hypothesis)');
                return;
            }
            
            console.log('Comparing nouns:', {nouns, minLogDice, maxPerNoun});
            document.getElementById('semanticGraph').innerHTML = '<div class="loading">Comparing noun profiles: ' + nouns.split(',').map(n => '"' + n.trim() + '"').join(', ') + '...</div>';
            document.getElementById('semanticDetails').innerHTML = '';
            
            try {
                const url = `${apiUrl}/api/semantic-field?nouns=${encodeURIComponent(nouns)}&min_logdice=${minLogDice}&max_per_noun=${maxPerNoun}`;
                const response = await fetch(url);
                
                if (!response.ok) {
                    throw new Error(`API returned ${response.status}`);
                }
                
                const data = await response.json();
                
                // Update stats
                document.getElementById('statFullyShared').textContent = data.fully_shared || 0;
                document.getElementById('statPartiallyShared').textContent = data.partially_shared || 0;
                document.getElementById('statSpecific').textContent = data.specific || 0;
                
                // Visualize graph
                visualizeSemanticField(data);
                
                // Show details panel with graded comparison
                renderSemanticDetails(data);
                
            } catch (e) {
                console.error('Comparison error:', e);
                document.getElementById('semanticGraph').innerHTML = `
                    <div class="error">
                        <strong>Semantic field comparison failed</strong><br>
                        ${e.message}<br>
                        <small>Make sure the API server is running at: ${apiUrl}</small>
                        <small style="display:block; margin-top:5px; color:#999;">Check browser console for details.</small>
                    </div>
                `;
            }
        }

        function renderSemanticDetails(data) {
            const detailsDiv = document.getElementById('semanticDetails');
            const nouns = data.nouns || [];

            currentSemanticData = data;
            currentSemanticAdjMap = {};
            (data.adjectives || []).forEach(adj => {
                if (adj.word) {
                    currentSemanticAdjMap[adj.word.toLowerCase()] = adj;
                }
            });
            
            let html = '';
            
            // Fully shared adjectives
            const fullyShared = (data.adjectives || []).filter(a => a.category === 'fully_shared');
            if (fullyShared.length > 0) {
                html += '<div class="sketch-section"><h3>üü¢ Fully Shared (all nouns)</h3>';
                html += renderComparisonTable(fullyShared, nouns);
                html += '</div>';
            }
            
            // Partially shared adjectives  
            const partiallyShared = (data.adjectives || []).filter(a => a.category === 'partially_shared');
            if (partiallyShared.length > 0) {
                html += '<div class="sketch-section"><h3>üü° Partially Shared (2+ nouns)</h3>';
                html += renderComparisonTable(partiallyShared, nouns);
                html += '</div>';
            }
            
            // Specific adjectives - group by noun
            const specific = (data.adjectives || []).filter(a => a.category === 'specific');
            if (specific.length > 0) {
                html += '<div class="sketch-section"><h3>üîµ Specific (one noun only)</h3>';
                
                // Group by the noun they're specific to
                const byNoun = {};
                for (const adj of specific) {
                    const noun = adj.specific_to || '?';
                    if (!byNoun[noun]) byNoun[noun] = [];
                    byNoun[noun].push(adj);
                }
                
                for (const noun of nouns) {
                    if (byNoun[noun] && byNoun[noun].length > 0) {
                        html += `<h4 style="margin: 15px 0 5px 0; color: #666;">Specific to "${noun}":</h4>`;
                        byNoun[noun].slice(0, 10).forEach(adj => {
                            const score = adj.max_logdice || 0;
                            html += `
                                <div class="collocation">
                                    <span class="word">${escapeHtml(adj.word)}</span>
                                    <span class="score">logDice: ${score.toFixed(1)}</span>
                                </div>
                            `;
                        });
                    }
                }
                html += '</div>';
            }
            
            if (!html) {
                html = '<div class="error">No adjectives found. Try lowering min_logdice.</div>';
            }
            
            detailsDiv.innerHTML = html;
        }
        
        function renderComparisonTable(adjectives, nouns) {
            let html = '<table style="width: 100%; border-collapse: collapse; font-size: 14px;">';
            html += '<tr style="background: #f5f5f5;"><th style="text-align: left; padding: 8px;">Adjective</th>';
            for (const noun of nouns) {
                html += `<th style="padding: 8px; text-align: center;">${escapeHtml(noun)}</th>`;
            }
            html += '</tr>';
            
            adjectives.slice(0, 20).forEach(adj => {
                const adjSafe = escapeJs(adj.word || '');
                html += `<tr class="adj-row" onclick="openRadialAdjective('${adjSafe}')" style="border-bottom: 1px solid #eee;">`;
                html += `<td style="padding: 8px; font-weight: 500;">${escapeHtml(adj.word)}</td>`;
                
                const scores = adj.noun_scores || {};
                for (const noun of nouns) {
                    const score = scores[noun] || 0;
                    const intensity = score > 0 ? Math.min(1, score / 10) : 0;
                    const bgColor = score > 0 
                        ? `rgba(74, 144, 217, ${intensity * 0.3})` 
                        : '#f9f9f9';
                    html += `<td style="padding: 8px; text-align: center; background: ${bgColor};">`;
                    html += score > 0 ? score.toFixed(1) : '-';
                    html += '</td>';
                }
                html += '</tr>';
            });
            
            html += '</table>';
            return html;
        }

        async function fetchExamples(adjective, noun) {
            // Ensure we have valid adjective and noun (not objects)
            const adj = typeof adjective === 'object' ? adjective.id : adjective;
            const n = typeof noun === 'object' ? noun.id : noun;
            
            // Hide panel during loading
            const panel = document.getElementById('examplesPanel');
            const titleEl = document.getElementById('examplesPanelTitle');
            const listEl = document.getElementById('examplesList');
            
            titleEl.textContent = `Examples: "${adj}" + "${n}" (loading...)`;
            listEl.innerHTML = '<div class="loading">Fetching examples...</div>';
            panel.style.display = 'block';
            
            try {
                const url = `${apiUrl}/api/semantic-field/examples?adjective=${encodeURIComponent(adj)}&noun=${encodeURIComponent(n)}&max=10`;
                const response = await fetch(url);
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json();
                
                // Update title
                titleEl.textContent = `Examples: "${adj}" + "${n}" (${data.count} found)`;
                
                // Display examples
                if (data.examples && data.examples.length > 0) {
                    listEl.innerHTML = data.examples.map((ex, i) => 
                        `<div style="margin: 8px 0; padding: 8px; background: #f8f9fa; border-radius: 4px;">
                            <strong>${i + 1}.</strong> ${highlightWords(ex, adj, n)}
                        </div>`
                    ).join('');
                } else {
                    listEl.innerHTML = '<div style="color: #999;">No examples found for this combination.</div>';
                }
                
            } catch (error) {
                titleEl.textContent = `Examples: "${adj}" + "${n}" (error)`;
                listEl.innerHTML = `<div class="error">Failed to fetch examples: ${error.message}</div>`;
            }
        }

        function highlightWords(sentence, word1, word2) {
            // Simple highlighting - case-insensitive
            const regex1 = new RegExp(`\\b${word1}\\w*`, 'gi');
            const regex2 = new RegExp(`\\b${word2}\\w*`, 'gi');
            
            return sentence
                .replace(regex1, '<mark style="background: #3498db; color: white; padding: 2px 4px; border-radius: 2px;">$&</mark>')
                .replace(regex2, '<mark style="background: #d94a4a; color: white; padding: 2px 4px; border-radius: 2px;">$&</mark>');
        }

        function visualizeSemanticField(data) {
            const container = document.getElementById('semanticGraph');
            container.innerHTML = '';
            
            const width = container.clientWidth;
            const height = 600;
            
            // Create SVG
            const svg = d3.select('#semanticGraph')
                .append('svg')
                .attr('width', width)
                .attr('height', height);
            
            // Prepare graph data
            const nodes = [];
            const links = [];
            const nounList = data.nouns || [];
            
            // Add nouns as nodes (positioned around center)
            nounList.forEach((noun, i) => {
                nodes.push({
                    id: noun,
                    type: 'noun',
                    isSeed: true
                });
            });
            
            // Add adjectives as nodes - use category for coloring
            (data.adjectives || []).forEach(adj => {
                nodes.push({
                    id: adj.word,
                    type: 'adjective',
                    category: adj.category,
                    presentIn: adj.present_in,
                    totalNouns: adj.total_nouns,
                    commonalityScore: adj.commonality_score
                });
            });
            
            // Add edges as links
            (data.edges || []).forEach(edge => {
                links.push({
                    source: edge.source,
                    target: edge.target,
                    logDice: edge.logDice
                });
            });
            
            // Create force simulation
            const simulation = d3.forceSimulation(nodes)
                .force('link', d3.forceLink(links).id(d => d.id).distance(100))
                .force('charge', d3.forceManyBody().strength(-300))
                .force('center', d3.forceCenter(width / 2, height / 2))
                .force('collision', d3.forceCollide().radius(30));
            
            // Draw links
            const link = svg.append('g')
                .selectAll('line')
                .data(links)
                .join('line')
                .attr('stroke', '#999')
                .attr('stroke-opacity', d => Math.min(1, d.logDice / 10))
                .attr('stroke-width', d => Math.max(1, d.logDice / 3))
                .attr('cursor', 'pointer')
                .on('click', function(event, d) {
                    // Fetch examples when clicking on an edge
                    fetchExamples(d.source.id, d.target.id);
                });
            
            // Draw nodes - color by category
            const node = svg.append('g')
                .selectAll('circle')
                .data(nodes)
                .join('circle')
                .attr('r', d => {
                    if (d.type === 'noun') return 12;
                    // Adjectives sized by presentIn count
                    return 4 + (d.presentIn || 1) * 2;
                })
                .attr('fill', d => {
                    if (d.type === 'noun') {
                        return '#d94a4a';  // Nouns in red
                    }
                    // Color adjectives by category
                    if (d.category === 'fully_shared') return '#2ecc71';   // Green
                    if (d.category === 'partially_shared') return '#f1c40f'; // Yellow
                    return '#3498db';  // Blue for specific
                })
                .attr('stroke', '#fff')
                .attr('stroke-width', 2)
                .attr('cursor', 'pointer')
                .call(d3.drag()
                    .on('start', dragstarted)
                    .on('drag', dragged)
                    .on('end', dragended));
            
            // Add labels
            const label = svg.append('g')
                .selectAll('text')
                .data(nodes)
                .join('text')
                .text(d => d.id)
                .attr('font-size', d => d.type === 'noun' ? 13 : 10)
                .attr('font-weight', d => (d.type === 'noun' || d.category === 'fully_shared') ? 'bold' : 'normal')
                .attr('dx', 12)
                .attr('dy', 4);
            
            // Add tooltips
            node.append('title')
                .text(d => {
                    if (d.type === 'noun') return d.id + ' (noun)';
                    const cat = d.category === 'fully_shared' ? 'all nouns' 
                        : d.category === 'partially_shared' ? 'some nouns' : 'specific';
                    return `${d.id} (${cat}, ${d.presentIn}/${d.totalNouns})`;
                });
            
            // Update positions on tick
            simulation.on('tick', () => {
                link
                    .attr('x1', d => d.source.x)
                    .attr('y1', d => d.source.y)
                    .attr('x2', d => d.target.x)
                    .attr('y2', d => d.target.y);
                
                node
                    .attr('cx', d => d.x)
                    .attr('cy', d => d.y);
                
                label
                    .attr('x', d => d.x)
                    .attr('y', d => d.y);
            });
            
            // Drag functions
            function dragstarted(event) {
                if (!event.active) simulation.alphaTarget(0.3).restart();
                event.subject.fx = event.subject.x;
                event.subject.fy = event.subject.y;
            }
            
            function dragged(event) {
                event.subject.fx = event.x;
                event.subject.fy = event.y;
            }
            
            function dragended(event) {
                if (!event.active) simulation.alphaTarget(0);
                event.subject.fx = null;
                event.subject.fy = null;
            }
        }

        // Enter key to search
        document.getElementById('wordInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') search();
        });
        
        // Enter key for semantic field
        document.getElementById('semanticNouns').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') runSemanticField();
        });
    </script>
</body>
</html>
